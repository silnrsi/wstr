---
// BibList component: list bibliographic sources related to given tag. If no tag supplied, 
// the list will be empty.
// Parameters:
//		tag: eg, 'encoding', 'script-arab', 'fonts', etc. Use 'all' to display the complete list.
//		entrytype: 'book', 'inbook', 'article', 'inproceedings', 'misc', 'online', 'non-online'
//      header: 

import BibEntry from './BibEntry.astro';
import { getCollection } from 'astro:content';
const sdata = await getCollection('sources');

const { tag, entrytype, header } = Astro.props;

let taggedSdata:Array<typeof sdata[0]> = [];
if (tag == "all") {
  taggedSdata = sdata;
} else if (tag) {
  taggedSdata = sdata.filter(sObj => 
    sObj.data.keywords && Array.isArray(sObj.data.keywords) && sObj.data.keywords.includes(tag)
  );
}

let entrytypes:Array<string> = [];
if (entrytype == 'non-online') {
	entrytypes = ['book', 'inbook', 'article', 'inproceedings', 'misc'];
} else if (entrytype && entrytype !== '') {
	entrytypes = entrytype.split(',');
	entrytypes = entrytypes.map(t => t.trim());
}

let typedSdata:Array<typeof sdata[0]> = [];
if (!entrytype || entrytype == '' || entrytype == 'all') {
	typedSdata = taggedSdata;
} else {
	typedSdata = taggedSdata.filter(sObj => entrytypes.includes(sObj.data.entrytype));
}

// Sort by sortname (or author) + title. The sortname *should* always be present, in theory.
const sortedSdata = [...typedSdata].sort((a, b) => 
	((a.data.sortname ?? (a.data.author ?? '')).concat(a.data.title)).localeCompare((b.data.sortname ?? (b.data.author ?? '')).concat(b.data.title))
);

---

{ (sortedSdata.length == 0) ? (
		null
	) : (
		<>
			{ (header !== '') ? (
				<h3>{header}</h3>
				) : null
			}
			<ul>
				{sortedSdata.map((sObj) =>
						<li><BibEntry key={sObj.id} /></li>
					)
				}
			</ul>
		</>
	)
}

